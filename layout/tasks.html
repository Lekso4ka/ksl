<section class="tasks" id="technology"><div class="tasks__text"><div class="text-item"><h4>задача</h4><h3>Как сократить затраты на транспорт и склады без потерь в клиентском сервисе?</h3></div><div class="text-item"><h4>Решение</h4><p>Оптимальное размещение складов и распределение запасов по ним снижают издержки благодаря лучшей загрузке транспорта и сокращению плеч доставки.</p></div></div><div class="tasks__decorate_center"><svg viewBox="0 0 20 306" fill="none" xmlns="http://www.w3.org/2000/svg"><rect class="fill_white" x="9" width="2" height="297" rx="1"></rect><rect class="t_progress fill_iris" x="9" width="2" height="0" rx="1"></rect><rect class="fill_white" x="0.55" y="0.55" width="18.9" height="18.9" rx="9.45"></rect><rect class="fill_white" x="0.55" y="95.55" width="18.9" height="18.9" rx="9.45"></rect><rect class="fill_white" x="0.55" y="190.55" width="18.9" height="18.9" rx="9.45"></rect><rect class="fill_white" x="0.55" y="285.55" width="18.9" height="18.9" rx="9.45"></rect><g><rect class="stroke_iris" x="0.55" y="0.55" width="18.9" height="18.9" rx="9.45" stroke-width="1.1"></rect><rect class="fill_iris" x="2" y="2" width="16" height="16" rx="8"></rect><path class="stroke_white" d="M5.7998 10.6L8.1998 13L14.1998 7" stroke-width="1.03529"></path></g><g class="group" style="opacity: 0"><rect class="stroke_iris" x="0.55" y="95.55" width="18.9" height="18.9" rx="9.45" stroke-width="1.1"></rect><rect class="fill_iris" x="2" y="97" width="16" height="16" rx="8"></rect><path class="stroke_white" d="M5.7998 105.6L8.1998 108L14.1998 102" stroke-width="1.03529"></path></g><g class="group" style="opacity: 0"><rect class="stroke_iris" x="0.55" y="190.55" width="18.9" height="18.9" rx="9.45" stroke-width="1.1"></rect><rect class="fill_iris" x="2" y="192" width="16" height="16" rx="8"></rect><path class="stroke_white" d="M5.7998 200.6L8.1998 203L14.1998 197" stroke-width="1.03529"></path></g><g class="group" style="opacity: 0"><rect class="stroke_iris" x="0.55" y="285.55" width="18.9" height="18.9" rx="9.45" stroke-width="1.1"></rect><rect class="fill_iris" x="2" y="287" width="16" height="16" rx="8"></rect><path class="stroke_white" d="M5.7998 295.6L8.1998 298L14.1998 292" stroke-width="1.03529"></path></g></svg></div><div class="tasks__block"><h4 class="tasks__label"><span class="label-txt">Какие задачи решает моделирование?</span><span class="cnt">/&#32;<span class="tasks-cnt">01</span>&#32; — 04 /</span></h4><div class="tasks__cards"><div class="tasks-item" data-order="1"><img src="images/tasks_1.svg" alt=""/><h3>Оценка соответствия логистической сети целям компании</h3><p>Где теряются деньги и в каких точках сеть работает неэффективно по сравнению с оптимальной.</p></div><div class="tasks-item" data-order="2"><img src="images/tasks_2.svg" alt=""/><h3>Быстрая адаптация к росту и изменениям стратегии</h3><p>Как перестроить логистику под рост бизнеса, региональную экспансию, изменение объемов или выход в новые каналы продаж (маркетплейсы и др.)</p></div><div class="tasks-item" data-order="3"><img src="images/tasks_3.svg" alt=""/><h3>Оценка эффекта от оптимизации сети</h3><p>Достоверный расчет экономии при переходе от текущих схем поставок к распределенной складской сети.</p></div><div class="tasks-item" data-order="4"><img src="images/tasks_4.svg" alt=""/><h3>Сравнение затрат на логистику с рынком</h3><p>Бенчмарк транспортных и складских затрат с отраслью и рыночными тарифами на склады и транспорт.</p></div></div></div><div class="tasks__decorate_bottom"></div></section><script>let tCards = document.querySelectorAll(".tasks-item");
const tLine = document.querySelector(".t_progress")
const tCnt = document.querySelector(".tasks-cnt")
const tdLine = document.querySelector(".tasks__decorate_bottom")
const tCheck = gsap.utils.toArray(".group")
const tTl = gsap.timeline({ paused: true });
let trgDt, trgMob, animating;
let toId = null;
const tCount = document.querySelector(".tasks-cnt");
const setTaskAnimationDt = () => {
    tTl
        .to(tCards[0], {
            transform: "translate(0, 100%)",
            opacity: 0,
            duration: 1
        })
        .to(tCheck[0], {
            opacity: 1,
            duration: .1
        }, "-=.1")
        .to(tCards[1], {
            transform: "translate(0, 0) scale(100%)",
            opacity: 1,
            backgroundColor: "white",
            duration: 1
        }, "-=1")
        .to(tCards[2], {
            transform: "translate(0, -.8rem) scale(94%)",
            opacity: .3,
            duration: 1
        }, "-=1")
        .to(tCards[3], {
            transform: "translate(0, -1.6rem) scale(88%)",
            opacity: .2,
            duration: 1
        }, "-=1")
        .to(tCards[1], {
            transform: "translate(0, 100%)",
            opacity: 0,
            duration: 1
        })
        .to(tCheck[1], {
            opacity: 1,
            duration: .1
        }, "-=.1")
        .to(tCards[2], {
            transform: "translate(0, 0) scale(100%)",
            opacity: 1,
            backgroundColor: "white",
            duration: 1
        }, "-=1")
        .to(tCards[3], {
            transform: "translate(0, -.8rem) scale(94%)",
            opacity: .3,
            duration: 1
        }, "-=1")
        .to(tCards[2], {
            transform: "translate(0, 100%)",
            opacity: 0,
            duration: 1
        })
        .to(tCheck[2], {
            opacity: 1,
            duration: .1
        }, "-=.1")
        .to(tCards[3], {
            transform: "translate(0, 0) scale(100%)",
            opacity: 1,
            backgroundColor: "white",
            duration: 1
        }, "-=1")
        .to(tLine, {
            height: 297,
            duration: 3,
            ease: "none"
        }, "-=3")

    trgDt = ScrollTrigger.create({
        trigger: ".second-section",
        start: `top center`,
        end: "+=3000",
        scrub: true,
        pin: true,
        onUpdate: (self) => {
            const progressCnt = 100 / (tCards.length);
            const current = Math.floor(self.progress * 100 / progressCnt)
            if (current <= tCards.length - 1) {
                tCnt.innerText = `0${ current + 1 }`
            }
            tTl.progress(self.progress)
        }
    });
}

function goFv() {
    animating = true;
    clearTimeout(toId);
    tdLine.classList.remove("active")
    const tl = gsap.timeline({
        defaults: {
            duration: 1.5,
            ease: "expo.inOut"
        },
        onComplete: () => {
            animating = false;
            tCards[0].parentElement.append(tCards[0])
            tCards = document.querySelectorAll(".tasks-item");
            tCards.forEach(c => {
                c.style = null
            })
            tdLine.classList.add("active")
            requestAnimationFrame(animateT)
        }
    })

    tl
        .to(tCards[0], {
            transform: "translate(calc(-100% - 40rem), 0)",
            duration: 1
        })
        .to(tCards[0], {
            opacity: 0,
            duration: -.5
        })
        .to(tCards[1], {
            transform: "translate(0, 0) scale(100%)",
            opacity: 1,
            backgroundColor: "white",
            duration: 1
        }, "-=1")
        .set(tCount, {
            text: `0${ tCards[1].dataset.order }`
        }, 1)
        .to(tCards[2], {
            transform: "translate(0, -.8rem) scale(94%)",
            opacity: .3,
            duration: 1
        }, "-=1")
        .to(tCards[3], {
            transform: "translate(0, -1.6rem) scale(88%)",
            opacity: .2,
            duration: 1
        }, "-=1")
        .to(tCards[0], {
            duration: .1,
            zIndex: 0,
            opacity: .1,
            backgroundColor: "#6F92E8"
        })
        .to(tCards[0], {
            transform: "translate(0, -2.4rem) scale(82%)",
            duration: .4,
            zIndex: 0
        })

}

function goBv() {
    animating = true;
    clearTimeout(toId)
    tdLine.classList.remove("active")
    const tl = gsap.timeline({
        defaults: {
            duration: 1.2,
            ease: "expo.inOut"
        },
        onComplete: () => {
            animating = false;
            tCards[3].parentElement.insertBefore(tCards[3], tCards[0])
            tCards = document.querySelectorAll(".tasks-item");
            tCards.forEach(c => {
                c.style = null
            })
            tdLine.classList.add("active")
            requestAnimationFrame(animateT)
        }
    })

    tl
        .to(tCards[3], {
            opacity: 0,
            duration: .1,
            zIndex: 0
        })
        .to(tCards[3], {
            duration: .1,
            zIndex: 4,
            transform: "translate(calc(-100% - 40rem), 0) scale(100%)",
            backgroundColor: "white"
        })
        .to(tCards[3], {
            transform: "translate(0, 0) scale(100%)",
            opacity: 1,
            duration: 1
        })
        .set(tCount, {
            text: `0${ tCards[3].dataset.order }`
        }, "-=1")
        .to(tCards[0], {
            transform: "translate(0, -.8rem) scale(94%)",
            backgroundColor: "#6F92E8",
            opacity: .3,
            duration: 1
        }, "-=1")
        .to(tCards[1], {
            transform: "translate(0, -1.6rem) scale(88%)",
            opacity: .2,
            duration: 1
        }, "-=1")
        .to(tCards[2], {
            transform: "translate(0, -2.4rem) scale(82%)",
            opacity: .1,
            duration: 1
        }, "-=1")

}
const setTaskAnimationMob = () => {
    //const isTouchDevice = 'ontouchstart' in window;
    let startY = 0;
    let startX = 0;
    trgMob = Observer.create({
        type: "touch,pointer",
        preventDefault: true,
        wheelSpeed: -1, // isTouchDevice ? 1 : -1,
        target: ".tasks__cards",
        y: "bottom bottom",
        onPress: function (self) {
            startY = self.y;
            startX = self.x;
        },
        onDrag: (self) => {
            const deltaY = Math.abs(self.y - startY);
            const deltaX = Math.abs(self.x - startX);
            if (deltaY > deltaX && deltaY > 10) {
                gsap.to(self.target, {
                    y: `+=${self.deltaY * 7}`
                });
                return;
            }
            const dragX = self.deltaX;
            if (animating) return;
            if (dragX < -10) {
                goFv(1)
            }
            else if (dragX > 10) {
                goBv(3);
            }
        },
        //onWheel: (self) => {
        //    console.log("ping")
        //    gsap.to(self.target, {
        //        y: `+=${ self.deltaY }`
        //    });
        //},
        //onRelease: function () {
        //    isVerticalScroll = false;
        //},
        tolerance: 10,
        //allowClicks: true,
        //lockAxis: false,
        //minimumMovement: 10,
        //allowEventBubbling: true
    });
}


function animateT () {
    if (!animating && tdLine.classList.contains("active")) {
        toId = setTimeout(() => {
            goFv()
        }, 5000)
    } else {
        clearTimeout(toId);
    }
}

function watchTasks(element) {
    const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
            if (entry.isIntersecting) {
                tdLine.classList.add("active")
                requestAnimationFrame(animateT)
            }
        });
    }, {
        threshold: 0
    });

    observer.observe(element);
    return observer;
}



if (window.innerWidth >= 1400) {
    setTaskAnimationDt()
} else {
    setTaskAnimationMob()
    watchTasks(tdLine);
}</script>
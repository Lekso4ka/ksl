section#directions.scenarios
    h4.label-btn.label-btn_light.label-btn_upper HORIZON
    h2.primary-caption.primary-caption_light.primary-caption_center
        span.primary-caption_iris Помогает развивать логистическую
        | &#32;
        span.primary-caption_iris_390_1440 сеть быстро,
        | &#32;гибко и с минимальными затратами
    .sq_line
    h4.cnt-b
        span Направление
        span.cnt
            | /&#32;
            span.sc-cnt 00
            | &#32; — 07 /
    div
        .circles-block
            .circles
                include vectors/circle1
                include vectors/circle2
                include vectors/circle1
                include vectors/circle2
                include vectors/circle1
                svg.sc_line_tb(width="759" height="1" viewBox="0 0 759 1" fill="none" xmlns="http://www.w3.org/2000/svg")
                    <line x1="-0.000488281" y1="0.5" x2="759" y2="0.5" stroke="#D6DCFF" stroke-opacity="0.2" stroke-dasharray="5 5"/>

                svg.sc_line_mob(viewBox="0 0 388 2" fill="none" xmlns="http://www.w3.org/2000/svg")
                    <path d="M0 0.559082L194 0.559065" stroke="#6F92E8" stroke-width="1.11818" stroke-dasharray="3.35 3.35"/>
                    <path d="M194 0.559082L388 0.559099" stroke="#6F92E8" stroke-width="1.11818" stroke-dasharray="3.35 3.35"/>

                svg.sc_line(viewBox="0 0 1440 1" fill="none" xmlns="http://www.w3.org/2000/svg")
                    line(x1="0" x2="1440" y1="0" y2="1" stroke="#6F92E833" stroke-width="2"
                    stroke-dasharray="4 4")
                    line.sc_progress(x1="0" x2="0" y1="0" y2="1" stroke="#6F92E8" stroke-width="2"
                        stroke-dasharray="4 4")
                .sc__item
                    span 01
                    span.l
                    span.c
                    span Размещение и количество складов
                .sc__item
                    span 02
                    span.l
                    span.c
                    span Размещение производств
                .sc__item
                    span 03
                    span.l
                    span.c
                    span Формат складов и модель владения
                .sc__item
                    span 04
                    span.l
                    span.c
                    span Рост и устойчивость сети
                .sc__item
                    span 05
                    span.l
                    span.c
                    span Частота поставок и работа с запасами
                .sc__item
                    span 06
                    span.l
                    span.c
                    span Клиентский<br>сервис
                .sc__item
                    span 07
                    span.l
                    span.c
                    span Адекватность логистических затрат
    .sc__decorate_bottom
    .figures_simple
        .line
        .line2
    div.ss
        div.sc
            div.sc-card
                h4 Сценарии и расчеты
                p Где открыть склады, чтобы снизить затраты без ухудшения сервиса?
            div.sc-card
                h4 Сценарии и расчеты
                p Что выгоднее расширить имеющийся склад или распределить запас по регионам продаж?
        div.sc
            div.sc-card
                h4 Сценарии и расчеты
                p Где открыть производство, чтобы снизить транспортные и производственные затраты?
            div.sc-card
                h4 Сценарии и расчеты
                p Что выгоднее производство и отдельный склад или производственно-складской комплекс?
            div.sc-card
                h4 Сценарии и расчеты
                p Как сбалансировать мощности где держать основное производство, а что выгоднее выпускать на сторонних площадках?
        div.sc
            div.sc-card
                h4 Сценарии и расчеты
                p Что выбрать аренду, собственные мощности или аутсорсинг?
            div.sc-card
                h4 Сценарии и расчеты
                p Как повлияет на затраты смена формата РЦ, консолидационный центр, кросс-док?
        div.sc
            div.sc-card
                h4 Сценарии и расчеты
                p Как изменится стоимость логистики при росте бизнеса — экспансии в регионы РФ, СНГ или другие страны?
            div.sc-card
                h4 Сценарии и расчеты
                p Где появятся узкие места, кратно удорожающие логистику?
            div.sc-card
                h4 Сценарии и расчеты
                p Есть ли риски утраты конкурентного преимущества, если ничего в бизнесе не менять?
        div.sc
            div.sc-card
                h4 Сценарии и расчеты
                p Как увеличить доходность бизнеса за счёт баланса частоты поставок и затрат?
            div.sc-card
                h4 Сценарии и расчеты
                p Как сбалансировать затраты на хранение и транспорт?
        div.sc
            div.sc-card
                h4 Сценарии и расчеты
                p Как через конфигурацию складской сети улучшить сервис, скорость доставки и NPS?
            div.sc-card
                h4 Сценарии и расчеты
                p Какой будет структура затрат при заданном уровне сервиса?
        div.sc
            div.sc-card
                h4 Сценарии и расчеты
                p Насколько затраты на транспорт и склады соответствуют отраслевому бенчмарку и рынку в целом?
        div.btn-block
            button.btn-label
                span запросить аудит
                <svg width="22" height="22" viewBox="0 0 22 22" fill="none" xmlns="http://www.w3.org/2000/svg">
                <rect width="22" height="22" rx="6" fill="#D6DCFF"/>
                <path d="M5 15.0518L8.38176 11.8311L10.5611 13.7528L16.9167 7M16.9167 7H13.3739M16.9167 7V10.5428" stroke="#212223" stroke-width="1.4"/>
                </svg>
        // TODO: вынести из блока
        div.ss__line
script.
    const scData = document.querySelectorAll(".sc__item")
    const scText = document.querySelectorAll(".sc")
    const line = document.querySelector(".sc_progress")
    const scCnt = document.querySelector(".sc-cnt")
    const scLine = document.querySelector(".sc__decorate_bottom")
    let scId

    const scDtAnimation = () => {
        function isElementInViewport(element) {
            const rect = element.getBoundingClientRect();
            return rect.top > window.innerHeight && rect.bottom <= window.innerHeight;
        }

        function watchElementInViewport(element, callback) {
            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (isElementInViewport(entry.target)) {
                        document.querySelector(".pre-work").style.setProperty("--posi", "fixed")
                    }
                });
            }, {
                threshold: 0
            });

            observer.observe(element);
            return observer;
        }

        watchElementInViewport(document.querySelector(".scenarios"));

        const lineAnimation = gsap.to(line, {
            attr: { x2: 1440 },
            duration: 1,
            ease: "none",
            paused: true
        });

        ScrollTrigger.create({
            trigger: ".circles",
            start: "center center",
            end: 10000,
            scrub: true,
            pin: true,
            onUpdate: (self) => {
                lineAnimation.progress(self.progress);
                const progressCnt = 100 / (scData.length + 1);
                const current = Math.floor(self.progress * 100 / progressCnt)
                if (current >= 1 && current < scData.length + 1) {
                    scData[current - 1].classList.add("active")
                    scText[current - 1].classList.add("active")
                    scData[current - 1].previousElementSibling?.classList.add("empty");
                    scText[current - 1].previousElementSibling?.classList.add("empty");
                    scText[current - 1].previousElementSibling?.classList.remove("active");
                    scData[current - 1].previousElementSibling?.classList.remove("active");
                    setTimeout(() => {
                        scText[current - 1].previousElementSibling?.classList.remove("empty")
                        scData[current - 1].previousElementSibling?.classList.remove("active");
                    }, 1000)
                }
                if (self.progress === 0 || self.progress === 1) {
                    document.querySelector(".pre-work").style.setProperty("--posi", "absolute")
                } else {
                    document.querySelector(".pre-work").style.setProperty("--posi", "fixed")
                }
                if (current <= 7) {
                    scCnt.innerText = `0${ current }`
                }
                scData.forEach((card, i) => {
                    if (i > current - 1 && card.classList.contains("active")) {
                        card.classList.remove("active")
                        scText[i].classList.remove("active")
                    }
                })
            }
        });
    }

    let scAnimating
    let n = 0
    const goScFv = (n) => {
        scAnimating = true
        clearTimeout(scId)
        scLine.classList.remove("active")
        scCnt.innerText = `0${n + 1}`
        const prevData = scData[n - 1] ? scData[n - 1] : scData[scData.length - 1]
        const prevText = scText[n - 1] ? scText[n - 1] : scText[scText.length - 1]
        scData[n].classList.add("active")
        scText[n].classList.add("active")
        prevData.classList.add("empty");
        prevText.classList.add("empty");
        prevText.classList.remove("active");
        prevData.classList.remove("active");
        setTimeout(() => {
            scAnimating = false
            prevText.classList.remove("empty")
            prevData.classList.remove("active");
            scLine.classList.add("active")
            requestAnimationFrame(animateSc)
        }, 1000)
    }
    const goScBv = (n) => {
        scAnimating = true
        clearTimeout(scId)
        scLine.classList.remove("active")
        scCnt.innerText = `0${n + 1}`
        const nextData = scData[n + 1] ? scData[n + 1] : scData[0]
        const nextText = scText[n + 1] ? scText[n + 1] : scText[0]
        scData[n].classList.add("active")
        scText[n].classList.add("active")
        nextData.classList.add("empty");
        nextText.classList.add("empty");
        nextData.classList.remove("active");
        nextText.classList.remove("active");
        setTimeout(() => {
            scAnimating = false
            nextText.classList.remove("empty")
            nextData.classList.remove("active");
            scLine.classList.add("active")
            requestAnimationFrame(animateSc)
        }, 1000)
    }
    const scMobAnimation = () => {
        let isVerticalScroll = false;
        let startY = 0;
        let startX = 0;
        Observer.create({
            type: "touch",
            preventDefault: true,
            wheelSpeed: -1,
            trigger: ".second-section",
            start: "bottom bottom",
            //pin: true,
            onPress: function (self) {
                startY = self.y;
                startX = self.x;
            },
            onDrag: (self) => {
                const deltaY = Math.abs(self.y - startY);
                const deltaX = Math.abs(self.x - startX);
                if (deltaY > deltaX && deltaY > 10) {
                    gsap.to(self.target, {
                        y: `+=${ self.deltaY * 10 }`
                    });
                    return;
                }
                if (scAnimating) return;
                const dragX = self.deltaX;
                if (dragX < -10) {
                    n = n >= scData.length - 1 ? 0 : n + 1
                    goScFv(n)
                } else if (dragX > 10) {
                    n = n <= 0 ? scData.length - 1 : n - 1
                    goScBv(n);
                }
            },
            onRelease: function () {
                isVerticalScroll = false;
            },
            tolerance: 10,
            allowClicks: true,
            lockAxis: false
        });
    }

    function animateSc() {
        if (!scAnimating && scLine.classList.contains("active")) {
            scId = setTimeout(() => {
                n = n >= scData.length - 1 ? 0 : n + 1
                goScFv(n)
            }, 5000)
        } else {
            clearTimeout(toId);
        }
    }

    function watchSc(element) {
        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                scData[n].classList.add("active")
                scText[n].classList.add("active")
                if (entry.isIntersecting) {
                    scLine.classList.add("active")
                    requestAnimationFrame(animateSc)
                }
            });
        }, {
            threshold: 0
        });

        observer.observe(element);
        return observer;
    }
    if (window.innerWidth >= 1400) {
        scDtAnimation()
    } else {
        scMobAnimation()
        watchSc(scLine)
    }
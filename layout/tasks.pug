section#technology.tasks
    .tasks__text
        div.text-item
            h4 задача
            h3 Как сократить затраты на транспорт и склады без потерь в клиентском сервисе?
        div.text-item
            h4 Решение
            p Оптимальное размещение складов и распределение запасов по ним снижают издержки благодаря лучшей загрузке транспорта и сокращению плеч доставки.
    .tasks__decorate_center
        include vectors/task_line
    div.tasks__block
        h4.tasks__label
            span.label-txt Какие задачи решает моделирование?
            span.cnt
                |/&#32;
                span.tasks-cnt 01
                |&#32; — 04 /
        div.tasks__cards
            div.tasks-item(data-order="1")
                img(src="images/tasks_1.svg" alt="")
                h3 Оценка соответствия логистической сети целям компании
                p Где теряются деньги и в каких точках сеть работает неэффективно по сравнению с оптимальной.
            div.tasks-item(data-order="2")
                img(src="images/tasks_2.svg" alt="")
                h3 Быстрая адаптация к росту и изменениям стратегии
                p Как перестроить логистику под рост бизнеса, региональную экспансию, изменение объемов или выход в новые каналы продаж (маркетплейсы и др.)
            div.tasks-item(data-order="3")
                img(src="images/tasks_3.svg" alt="")
                h3 Оценка эффекта от оптимизации сети
                p Достоверный расчет экономии при переходе от текущих схем поставок к распределенной складской сети.
            div.tasks-item(data-order="4")
                img(src="images/tasks_4.svg" alt="")
                h3 Сравнение затрат на логистику с рынком
                p Бенчмарк транспортных и складских затрат с отраслью и рыночными тарифами на склады и транспорт.
    .tasks__decorate_bottom
script.
    let tCards = document.querySelectorAll(".tasks-item");
    const tLine = document.querySelector(".t_progress")
    const tCnt = document.querySelector(".tasks-cnt")
    const tdLine = document.querySelector(".tasks__decorate_bottom")
    const tCheck = gsap.utils.toArray(".group")
    const tTl = gsap.timeline({ paused: true });
    let trgDt, trgMob, animating;
    let toId = null;
    const tCount = document.querySelector(".tasks-cnt");
    const setTaskAnimationDt = () => {
        tTl
            .to(tCards[0], {
                transform: "translate(0, 100%)",
                opacity: 0,
                duration: 1
            })
            .to(tCheck[0], {
                opacity: 1,
                duration: .1
            }, "-=.1")
            .to(tCards[1], {
                transform: "translate(0, 0) scale(100%)",
                opacity: 1,
                backgroundColor: "white",
                duration: 1
            }, "-=1")
            .to(tCards[2], {
                transform: "translate(0, -.8rem) scale(94%)",
                opacity: .3,
                duration: 1
            }, "-=1")
            .to(tCards[3], {
                transform: "translate(0, -1.6rem) scale(88%)",
                opacity: .2,
                duration: 1
            }, "-=1")
            .to(tCards[1], {
                transform: "translate(0, 100%)",
                opacity: 0,
                duration: 1
            })
            .to(tCheck[1], {
                opacity: 1,
                duration: .1
            }, "-=.1")
            .to(tCards[2], {
                transform: "translate(0, 0) scale(100%)",
                opacity: 1,
                backgroundColor: "white",
                duration: 1
            }, "-=1")
            .to(tCards[3], {
                transform: "translate(0, -.8rem) scale(94%)",
                opacity: .3,
                duration: 1
            }, "-=1")
            .to(tCards[2], {
                transform: "translate(0, 100%)",
                opacity: 0,
                duration: 1
            })
            .to(tCheck[2], {
                opacity: 1,
                duration: .1
            }, "-=.1")
            .to(tCards[3], {
                transform: "translate(0, 0) scale(100%)",
                opacity: 1,
                backgroundColor: "white",
                duration: 1
            }, "-=1")
            .to(tLine, {
                height: 297,
                duration: 3,
                ease: "none"
            }, "-=3")

        trgDt = ScrollTrigger.create({
            trigger: ".second-section",
            start: `top center`,
            end: "+=3000",
            scrub: true,
            pin: true,
            onUpdate: (self) => {
                const progressCnt = 100 / (tCards.length);
                const current = Math.floor(self.progress * 100 / progressCnt)
                if (current <= tCards.length - 1) {
                    tCnt.innerText = `0${ current + 1 }`
                }
                tTl.progress(self.progress)
            }
        });
    }

    function goFv() {
        animating = true;
        clearTimeout(toId);
        tdLine.classList.remove("active")
        const tl = gsap.timeline({
            defaults: {
                duration: 1.5,
                ease: "expo.inOut"
            },
            onComplete: () => {
                animating = false;
                tCards[0].parentElement.append(tCards[0])
                tCards = document.querySelectorAll(".tasks-item");
                tCards.forEach(c => {
                    c.style = null
                })
                tdLine.classList.add("active")
                requestAnimationFrame(animateT)
            }
        })

        tl
            .to(tCards[0], {
                transform: "translate(calc(-100% - 40rem), 0)",
                duration: 1
            })
            .to(tCards[0], {
                opacity: 0,
                duration: -.5
            })
            .to(tCards[1], {
                transform: "translate(0, 0) scale(100%)",
                opacity: 1,
                backgroundColor: "white",
                duration: 1
            }, "-=1")
            .set(tCount, {
                text: `0${ tCards[1].dataset.order }`
            }, 1)
            .to(tCards[2], {
                transform: "translate(0, -.8rem) scale(94%)",
                opacity: .3,
                duration: 1
            }, "-=1")
            .to(tCards[3], {
                transform: "translate(0, -1.6rem) scale(88%)",
                opacity: .2,
                duration: 1
            }, "-=1")
            .to(tCards[0], {
                duration: .1,
                zIndex: 0,
                opacity: .1,
                backgroundColor: "#6F92E8"
            })
            .to(tCards[0], {
                transform: "translate(0, -2.4rem) scale(82%)",
                duration: .4,
                zIndex: 0
            })

    }

    function goBv() {
        animating = true;
        clearTimeout(toId)
        tdLine.classList.remove("active")
        const tl = gsap.timeline({
            defaults: {
                duration: 1.2,
                ease: "expo.inOut"
            },
            onComplete: () => {
                animating = false;
                tCards[3].parentElement.insertBefore(tCards[3], tCards[0])
                tCards = document.querySelectorAll(".tasks-item");
                tCards.forEach(c => {
                    c.style = null
                })
                tdLine.classList.add("active")
                requestAnimationFrame(animateT)
            }
        })

        tl
            .to(tCards[3], {
                opacity: 0,
                duration: .1,
                zIndex: 0
            })
            .to(tCards[3], {
                duration: .1,
                zIndex: 4,
                transform: "translate(calc(-100% - 40rem), 0) scale(100%)",
                backgroundColor: "white"
            })
            .to(tCards[3], {
                transform: "translate(0, 0) scale(100%)",
                opacity: 1,
                duration: 1
            })
            .set(tCount, {
                text: `0${ tCards[3].dataset.order }`
            }, "-=1")
            .to(tCards[0], {
                transform: "translate(0, -.8rem) scale(94%)",
                backgroundColor: "#6F92E8",
                opacity: .3,
                duration: 1
            }, "-=1")
            .to(tCards[1], {
                transform: "translate(0, -1.6rem) scale(88%)",
                opacity: .2,
                duration: 1
            }, "-=1")
            .to(tCards[2], {
                transform: "translate(0, -2.4rem) scale(82%)",
                opacity: .1,
                duration: 1
            }, "-=1")

    }
    const setTaskAnimationMob = () => {

        trgMob = Observer.create({
            type: "touch",
            preventDefault: true,
            wheelSpeed: -1,
            target: ".tasks",
            y: -100,
            //pin: true,
            onDrag: (self) => {
                const dragX = self.deltaX;
                if (animating) return;
                if (dragX < -50) {
                    goFv(1)
                }
                else if (dragX > 50) {
                    goBv(3);
                }
            },

            tolerance: 10
        });
    }
    

    function animateT () {
        if (!animating && tdLine.classList.contains("active")) {
            toId = setTimeout(() => {
                goFv()
            }, 5000)
        } else {
            clearTimeout(toId);
        }
    }

    function watchTasks(element) {
        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    tdLine.classList.add("active")
                    requestAnimationFrame(animateT)
                }
            });
        }, {
            threshold: 0
        });

        observer.observe(element);
        return observer;
    }



    if (window.innerWidth >= 1400) {
        setTaskAnimationDt()
    } else {
        setTaskAnimationMob()
        watchTasks(tdLine);
    }